<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Home</title>

  <link rel="preload" href="./wallpaper-dark.jpg" as="image" />

  <style>
    :root{
      --bg: #0c0c0d;
      --bg-elev: #171516;
      --ink: #e9e9ea;
      --ink-dim: #b7b7b9;
      --accent: #6aa3ff;
      --radius-xl: 28px;
      --shadow: 0 12px 60px rgba(0,0,0,.55);
      --shadow-strong: 0 18px 70px rgba(0,0,0,.65);
      --btn: #232224;
      --btn-hover: #2b292c;
      --suggest-bg: rgba(18,17,18,.9);
      --suggest-hover: #1d1b1e;

      --dock-top: 6vh;
      --bar-h: 60px;

      /* Shortcuts */
      --tile: 94px;
      --tile-gap: 10px;
      --tile-radius: 16px;
    }

    /* Base */
    html, body {
      height: 100%;
      background-color: var(--bg);
      background-image: url("./wallpaper-dark.jpg");
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      background-attachment: fixed;

      color: var(--ink);
      font: 16px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,"Apple Color Emoji","Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

      margin: 0;
      overflow: hidden;
      overscroll-behavior: none;
    }
    body::before{
      content:"";
      position: fixed; inset: 0;
      background: radial-gradient(1200px 600px at 50% 35%, rgba(0,0,0,.25), rgba(0,0,0,.65) 70%);
      pointer-events: none;
      z-index: 0;
    }

    .dock {
      position: fixed;
      top: var(--dock-top);
      left: 50%;
      transform: translateX(-50%);
      width: min(820px, calc(100vw - 2rem));
      z-index: 10;
    }

    .bar {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 10px;
      background: rgba(16,14,15,.9);
      border-radius: var(--radius-xl);
      padding: 8px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: saturate(120%) blur(6px);
      position: relative;
      transition: box-shadow .15s ease, transform .15s ease;
      user-select: none;
    }
    .bar.drop-active {
      box-shadow: 0 0 0 2px rgba(106,163,255,.5), var(--shadow-strong);
      transform: translateZ(0);
    }
    .bar:focus-within { box-shadow: var(--shadow); }
    .bar *:focus,
    .bar *:focus-visible { outline: none !important; box-shadow: none !important; }

    .drop-hint {
      position: absolute; inset: 2px;
      border-radius: inherit;
      display: none;
      align-items: center; justify-content: center;
      background: rgba(30,30,40,.25);
      border: 2px dashed rgba(106,163,255,.55);
      color: var(--ink);
      font-size: .95rem;
      pointer-events: none;
      backdrop-filter: blur(2px);
    }
    .bar.drop-active .drop-hint { display: flex; }

    /* Input */
    .form { display: contents; }
    .q {
      width: 100%;
      height: 44px;
      padding: 0 6px;
      color: var(--ink);
      background: transparent;
      border: none;
      outline: none;
      font-size: 1.05rem;
      caret-color: var(--accent);
    }
    .q::placeholder { color: var(--ink-dim); opacity: .6; }

    /* Action cluster (right side) */
    .actions {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--bg-elev);
      height: 44px;
      padding: 0 6px 0 10px;
      border-radius: 999px;
    }
    .btn {
      width: 36px; height: 36px;
      display: grid; place-items: center;
      border-radius: 999px;
      background: var(--btn);
      color: var(--ink);
      border: 0;
      cursor: pointer;
      transition: transform .12s ease, background-color .12s ease, opacity .12s ease;
    }
    .btn:hover { background: var(--btn-hover); }
    .btn:active { transform: scale(.96); }
    .btn[disabled] { opacity: .45; cursor: not-allowed; }

    /* Voice recording pulse */
    .voice.recording {
      background: #2f2c32;
      box-shadow: 0 0 0 0 rgba(106,163,255,.35);
      animation: pulse 1.2s infinite;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(106,163,255,.35); }
      70% { box-shadow: 0 0 0 10px rgba(106,163,255,0); }
      100% { box-shadow: 0 0 0 0 rgba(106,163,255,0); }
    }

    .lens { width: 40px; height: 40px; }
    .lens svg { width: 20px; height: 20px; }

    .ai { width: 44px; height: 44px; margin-left: 4px; }

    .suggest {
      position: absolute;
      left: 0; right: 0;
      top: calc(100% + 10px);
      margin: 0;
      padding: 8px;
      list-style: none;
      background: var(--suggest-bg);
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0,0,0,.6);
      backdrop-filter: blur(6px) saturate(120%);
      max-height: calc(100vh - var(--dock-top) - var(--bar-h) - 20px);
      overflow-x: hidden;
      display: none;
      z-index: 9;
    }
    .suggest.show { display: block; }
    .suggest li {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 10px;
      color: var(--ink);
      cursor: pointer;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }
    .suggest li:hover,
    .suggest li.active { background: var(--suggest-hover); }
    .s-icon { width: 18px; height: 18px; opacity: .7; }

    @media (prefers-reduced-motion: reduce) { .btn { transition: none; } }

    /* Shortcuts */
    .shortcuts {
      position: fixed;
      top: calc(var(--dock-top) + var(--bar-h) + 18px);
      left: 50%;
      transform: translateX(-50%);
      width: min(900px, calc(100vw - 2rem));
      background: rgba(16,14,15,.82);
      border-radius: 20px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px) saturate(120%);
      padding: 10px 12px 12px;
      z-index: 5;
      user-select: none;
    }
    .shortcuts .sc-bar{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding: 2px 2px 8px;
    }
    .shortcuts .sc-title{
      font-size:.9rem; color:var(--ink-dim); letter-spacing:.02em;
      opacity:.85;
    }
    .shortcuts .sc-actions{
      display:flex; align-items:center; gap:6px;
      background: var(--bg-elev);
      border-radius: 999px;
      padding: 3px;
    }
    .btn.tiny{ width:32px; height:32px; }

    .tiles{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(var(--tile), 1fr));
      gap: var(--tile-gap);
      margin: 0; padding: 0; list-style: none; /* alignment fix: remove default ul spacing */
    }
    .tile{
      position:relative;
      background: var(--btn);
      border: 1px solid rgba(255,255,255,.04);
      border-radius: var(--tile-radius);
      height: var(--tile);
      padding: 8px 8px;
      display:grid;
      grid-template-rows: 1fr auto;
      align-items:center; justify-items:center;
      cursor:pointer;
      transition: background-color .12s ease, transform .12s ease;
    }
    .tile:hover{ background: var(--btn-hover); }
    .tile.dragging{ opacity: .5; }
    .tile .favicon{
      width: 28px; height: 28px; border-radius: 6px;
      background: #2a2a2c; display:grid; place-items:center;
      overflow:hidden;
    }
    .tile .favicon img{ width:100%; height:100%; object-fit:cover; display:block; }
    .tile .label{
      width: 100%;
      font-size: .78rem; color: var(--ink); opacity: .96;
      text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    /* In-tile actions (Edit + Delete) */
    .tile .action{
      position:absolute; top:6px;
      width: 24px; height: 24px;
      display:none; place-items:center;
      border-radius: 8px;
      background: var(--btn);
      border: 1px solid rgba(255,255,255,.06);
      color: var(--ink);
      cursor: pointer;
      transition: background-color .12s ease, opacity .12s ease, transform .12s ease;
    }
    .tile .action:hover{ background: var(--btn-hover); }
    .tile .edit{ right: 34px; }
    .tile .remove{ right: 6px; }
    .tile .action svg{
      width: 14px; height: 14px; display:block;
      stroke-linecap: round; stroke-linejoin: round;
    }
    .shortcuts.edit .tile .action,
    .folder-view.edit .tile .action { display:grid; }

    /* Folder tile icon */
    .tile.folder .favicon { background: transparent; }
    .tile.folder .folder-ico{
      width: 28px; height: 28px; display:grid; place-items:center;
    }
    .tile.folder .folder-ico svg{
      width: 26px; height: 26px; opacity: .95;
    }
    .tile.folder .count{
      position:absolute; bottom:6px; right:6px;
      font-size:.7rem; color: var(--ink-dim); opacity:.8;
    }

    /* Folder view overlay */
    .folder-view{
      position:absolute; inset: 8px;
      background: rgba(18,17,18,.95);
      border-radius: 16px;
      box-shadow: var(--shadow-strong);
      display:none;
      grid-template-rows: auto 1fr;
      padding: 10px;
      z-index: 6;
      overflow: hidden;
    }
    .folder-view.show{ display:grid; }
    .folder-view .fv-bar{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 2px 2px 8px;
    }
    .folder-view .fv-left{
      display:flex; align-items:center; gap:8px;
    }
    .folder-view .fv-title{
      font-size:.95rem; color: var(--ink); font-weight:600; letter-spacing:.02em;
    }
    .folder-view .fv-actions{
      display:flex; align-items:center; gap:6px;
      background: var(--bg-elev);
      border-radius: 999px;
      padding: 3px;
    }
    .folder-view .fv-grid{
      overflow: auto; /* internal scroll */
      -webkit-overflow-scrolling: touch;
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(var(--tile), 1fr));
      gap: var(--tile-gap);
      margin: 0; padding: 0; list-style: none; /* alignment fix inside folder */
    }

    /* Dialog + overlay */
    .overlay{
      position: fixed; inset: 0;
      background: rgba(0,0,0,.4);
      backdrop-filter: blur(1px);
      display:none; z-index: 20;
    }
    .overlay.show{ display:block; }
    .sc-dialog{
      position: fixed; left: 50%; top: 50%;
      transform: translate(-50%,-50%);
      width: min(420px, calc(100vw - 2rem));
      background: rgba(18,17,18,.95);
      border-radius: 18px;
      box-shadow: var(--shadow-strong);
      padding: 14px;
      display:none; z-index: 21;
    }
    .sc-dialog.show{ display:block; }
    .sc-dialog h3{
      margin: 6px 4px 12px; font-size: 1rem; font-weight: 600;
      color: var(--ink);
    }
    .sc-dialog .row{
      display:flex; flex-direction:column; gap:6px; margin: 10px 4px;
    }
    .sc-dialog label{ font-size:.85rem; color: var(--ink-dim); }
    .sc-dialog input, .sc-dialog select{
      height: 38px; border-radius: 10px; border: 1px solid rgba(255,255,255,.06);
      background: #1b191c; color: var(--ink); padding: 0 10px;
      outline:none;
    }
    .sc-dialog .actions{
      display:flex; justify-content:flex-end; gap:8px; margin-top: 12px;
    }
    .sc-dialog .btn{
      width: auto; min-width: 88px;
      height: 36px; padding: 0 14px;
      display: inline-flex; align-items: center; justify-content: center;
      white-space: nowrap;
    }
    .sc-dialog .btn.primary{
      background: #2b2a2f; color: var(--ink); border-radius: 10px;
    }
    .sc-dialog .btn.ghost{
      background: transparent; border: 1px solid rgba(255,255,255,.08);
      color: var(--ink); border-radius: 10px;
    }

    @media (max-width: 520px){
      :root { --tile: 86px; }
      .shortcuts { width: min(680px, calc(100vw - 1.5rem)); }
    }
  </style>
</head>
<body>
  <!-- Fixed top-center dock -->
  <div class="dock" aria-label="Search dock">
    <div id="bar" class="bar" role="search" aria-label="Search">
      <!-- Search form -->
      <form id="form" class="form" action="https://www.google.com/search" method="GET" autocomplete="off" target="_self">
        <input id="q" class="q" name="q" type="text" inputmode="search" spellcheck="false" aria-label="Search Google" placeholder="Search Google" />
      </form>

      <!-- Actions -->
      <div class="actions" aria-label="Quick actions">
        <button id="go" class="btn go" type="button" title="Search" aria-label="Search">
          <svg aria-hidden="true" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 12h18M12 3l9 9-9 9"></path>
          </svg>
        </button>

        <button id="voice" class="btn voice" type="button" title="Search by voice" aria-label="Search by voice">
          <svg aria-hidden="true" width="18" height="18" viewBox="0 0 24 24" fill="none">
            <rect x="9" y="3" width="6" height="10" rx="3" fill="currentColor"/>
            <path d="M5 11a7 7 0 0 0 14 0" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
            <path d="M12 18v3" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
          </svg>
        </button>

        <!-- Use Google Images upload endpoint to avoid Lens 403 on cross-origin POST -->
        <form id="lensForm" action="https://www.google.com/searchbyimage/upload" method="POST" enctype="multipart/form-data" target="_blank" style="display:contents">
          <input id="lensFile" type="file" name="image_file" accept="image/*" style="display:none" />
          <input id="lensHl" type="hidden" name="hl" value="en" />
          <button id="lensBtn" class="btn lens" type="button" title="Search with an image" aria-label="Search with an image">
            <svg aria-hidden="true" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3.75" y="3.75" width="16.5" height="16.5" rx="5"/>
              <circle cx="12" cy="12" r="4.25"/>
              <circle cx="15.8" cy="8.2" r="1.1" fill="currentColor" stroke="none" />
            </svg>
          </button>
        </form>

        <button id="ai" class="btn ai" type="button" title="AI Mode" aria-label="AI Mode">
          <svg aria-hidden="true" width="19" height="19" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="6"></circle>
            <path d="M16 16l5 5"></path>
          </svg>
        </button>
      </div>

      <div class="drop-hint">Drop an image to search with Google Lens</div>
    </div>

    <!-- Suggestions -->
    <ul id="sugg" class="suggest" role="listbox" aria-label="Search suggestions"></ul>
  </div>

  <!-- Shortcuts -->
  <section id="shortcuts" class="shortcuts" aria-label="Shortcuts">
    <div class="sc-bar">
      <div class="sc-title">Shortcuts</div>
      <div class="sc-actions">
        <button id="scAdd" class="btn tiny" title="Add shortcut" aria-label="Add shortcut">
          <svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 5v14M5 12h14"/>
          </svg>
        </button>
        <button id="scAddFolder" class="btn tiny" title="New folder" aria-label="New folder">
          <svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 7h6l2 2h10v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
            <path d="M12 11v6M9 14h6"/>
          </svg>
        </button>

        <!-- Import/Export -->
        <button id="scExport" class="btn tiny" title="Export shortcuts" aria-label="Export shortcuts">
          <svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 3v10"></path>
            <path d="M7 8l5-5 5 5"></path>
            <path d="M5 21h14a2 2 0 0 0 2-2v-5"></path>
          </svg>
        </button>
        <button id="scImport" class="btn tiny" title="Import shortcuts" aria-label="Import shortcuts">
          <svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 21V11"></path>
            <path d="M17 16l-5 5-5-5"></path>
            <path d="M19 3H5a2 2 0 0 0-2 2v5"></path>
          </svg>
        </button>
        <input id="scImportFile" type="file" accept="application/json,.json" style="display:none" />

        <button id="scEdit" class="btn tiny" title="Reorder / delete" aria-label="Edit" aria-pressed="false">
          <svg id="scEditIcon" aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 21h4l11-11a2.5 2.5 0 0 0-4-4L4 17v4z"></path>
          </svg>
        </button>
      </div>
    </div>
    <ul id="scGrid" class="tiles" role="list"></ul>

    <!-- Folder overlay -->
    <div id="folderView" class="folder-view" aria-hidden="true">
      <div class="fv-bar">
        <div class="fv-left">
          <button id="fvBack" class="btn tiny" title="Close folder" aria-label="Close folder">
            <svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M15 18l-6-6 6-6"/>
            </svg>
          </button>
          <div id="fvTitle" class="fv-title">Folder</div>
        </div>
        <div class="fv-actions">
          <button id="fvToggleEdit" class="btn tiny" title="Edit shortcuts in this folder" aria-label="Edit folder contents" aria-pressed="false">
            <svg id="fvToggleIcon" aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M4 21h4l11-11a2.5 2.5 0 0 0-4-4L4 17v4z"></path>
            </svg>
          </button>
          <button id="fvAdd" class="btn tiny" title="Add shortcut to folder" aria-label="Add shortcut">
            <svg aria-hidden="true" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 5v14M5 12h14"/>
            </svg>
          </button>
        </div>
      </div>
      <ul id="fvGrid" class="fv-grid" role="list"></ul>
    </div>
  </section>

  <!-- Dialog + overlay -->
  <div id="scOverlay" class="overlay" aria-hidden="true"></div>
  <div id="scDialog" class="sc-dialog" role="dialog" aria-modal="true" aria-labelledby="scDialogTitle">
    <h3 id="scDialogTitle">Add shortcut</h3>
    <form id="scForm" autocomplete="off">
      <div class="row">
        <label for="scTitle">Name</label>
        <input id="scTitle" name="title" type="text" placeholder="e.g., YouTube" />
      </div>
      <div class="row" id="rowUrl">
        <label for="scUrl">URL</label>
        <input id="scUrl" name="url" type="url" placeholder="https://example.com" inputmode="url" />
      </div>
      <div class="row" id="rowLocation">
        <label id="scLocationLabel" for="scLocation">Add to</label>
        <select id="scLocation" name="location"></select>
      </div>
      <div class="actions">
        <button type="button" id="scCancel" class="btn ghost">Cancel</button>
        <button type="submit" class="btn primary">Save</button>
      </div>
    </form>
  </div>

  <!-- App scripts -->
  <script>
    (() => {
      'use strict';

      // Extension bridge: talk to the new-tab extension's content script if present
      const EXT = (() => {
        const ORIGIN = location.origin;
        let reqId = 0;
        const pending = new Map();
        let connected = false;
        let toolbarRootId = null;

        function call(method, params = {}, timeout = 5000) {
          return new Promise((resolve, reject) => {
            const id = `rpc_${Date.now()}_${++reqId}`;
            console.debug('[Home New Tab] Calling extension method:', method, 'with params:', params);
            const t = setTimeout(() => {
              pending.delete(id);
              reject(new Error('EXT timeout'));
            }, timeout);
            pending.set(id, { resolve, reject, timer: t });
            try {
              window.postMessage({ __ntb: true, id, method, params }, ORIGIN);
            } catch (e) {
              clearTimeout(t); pending.delete(id); reject(e);
            }
          });
        }

        // Handle replies and broadcasts
        window.addEventListener('message', (event) => {
          if (event.source !== window) return;
          const d = event.data;
          if (d && d.__ntb_ready === true) {
            // Content script is injected; attempt to connect immediately
            // Content script ready; attempt to connect
            EXT.connect(1).then((data) => { if (data && Array.isArray(data.items)) { state.items = data.items; scImport.setAttribute('disabled','true'); render(); } });
            return;
          }
          // Only process replies that include an explicit ok boolean
          if (d && d.__ntb === true && typeof d.ok === 'boolean') {
            const entry = pending.get(d.id);
            if (entry) {
              clearTimeout(entry.timer);
              pending.delete(d.id);
              d.ok ? entry.resolve(d.result) : entry.reject(new Error(d.error || 'EXT error'));
            }
          } else if (d && d.__ntb_broadcast === true) {
            // Live updates; debounce a refresh
            EXT._notifyChange();
          }
        });

        async function connect(attempts = 5) {
          if (connected) return { id: toolbarRootId, items: state.items }; // already connected
          for (let i = 0; i < attempts; i++) {
            try {
              const data = await call('getToolbar', {}, 4000);
              toolbarRootId = data?.id || null;
              connected = !!toolbarRootId;
              if (connected) { return data; }
            } catch (err) {
              // ignore and retry
            }
            if (i < attempts - 1) await new Promise(r => setTimeout(r, 600));
          }
          return null;
        }

        // Public API
        return {
          connect,
          isConnected: () => connected,
          getToolbar: () => call('getToolbar'),
          createLink: (args) => call('createLink', args),
          createFolder: (args) => call('createFolder', args),
          updateNode: (args) => call('updateNode', args),
          moveNode: (args) => call('moveNode', args),
          removeNode: (args) => call('removeNode', args),
          getToolbarRootId: () => toolbarRootId,
          _notifyChange: (() => {
            let t = null;
            return () => { clearTimeout(t); t = setTimeout(() => { if (typeof window.__extRefresh === 'function') window.__extRefresh(); }, 120); };
          })(),
        };
      })();

      // Utilities
      const $ = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
      const on = (el, evts, fn) => evts.split(' ').forEach(e => el.addEventListener(e, fn));
      const escapeHTML = (s) => String(s ?? '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]));

      // Search and actions (kept minimal)
      const bar = $('#bar');
      const form = $('#form');
      const q = $('#q');
      const go = $('#go');
      const voice = $('#voice');
      const lensBtn = $('#lensBtn');
      const lensFile = $('#lensFile');
      const lensForm = $('#lensForm');
      const ai = $('#ai');
      const sugg = $('#sugg');

      const submitSearch = () => {
        const v = q.value.trim();
        if (!v) { q.focus(); return; }
        form.submit();
      };
      on(go, 'click', submitSearch);
      on(form, 'submit', (e) => { if (!q.value.trim()) { e.preventDefault(); q.focus(); } });

      const SUGGESTIONS_CONFIG = { maxItems: 8, timeout: 3000, fallbackSuggestions: ["news","weather","maps","translate","time","calculator","currency converter","nearby restaurants","youtube","gmail"] };
      let activeIndex = -1, lastQuery = '';

      const cleanupSuggestionScript = () => { const s = document.querySelector('#suggestions-script'); if (s) s.remove(); };
      const getFallbackSuggestions = (text) => SUGGESTIONS_CONFIG.fallbackSuggestions.filter(s => s.includes((text||'').toLowerCase())).slice(0, SUGGESTIONS_CONFIG.maxItems);
      const fetchSuggestions = async (text) => new Promise((resolve) => {
        try {
          cleanupSuggestionScript();
          const cb = `suggCallback_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
          window[cb] = (data) => { try { delete window[cb]; cleanupSuggestionScript(); resolve(Array.isArray(data?.[1]) ? data[1] : []); } catch { resolve([]); } };
          const script = document.createElement('script');
          script.id = 'suggestions-script';
          script.src = `https://suggestqueries.google.com/complete/search?client=firefox&hl=en&callback=${cb}&q=${encodeURIComponent(text)}`;
          script.onerror = () => { delete window[cb]; cleanupSuggestionScript(); resolve(getFallbackSuggestions(text)); };
          document.head.appendChild(script);
          setTimeout(() => { if (window[cb]) { delete window[cb]; cleanupSuggestionScript(); resolve(getFallbackSuggestions(text)); } }, SUGGESTIONS_CONFIG.timeout);
        } catch { resolve(getFallbackSuggestions(text)); }
      });

      const renderSuggestions = (items) => {
        if (!items || !items.length) { sugg.classList.remove('show'); sugg.innerHTML=''; return; }
        const safe = (t) => t.replace(/"/g,'&quot;').replace(/</g,'&lt;');
        sugg.innerHTML = items.slice(0, SUGGESTIONS_CONFIG.maxItems).map((t,i)=>`
          <li role="option" data-index="${i}" aria-selected="false" title="${safe(t)}">
            <svg class="s-icon" viewBox="0 0 24 24" aria-hidden="true"><circle cx="11" cy="11" r="6" fill="currentColor" /></svg>
            <span>${safe(t)}</span>
          </li>`).join('');
        activeIndex = -1; sugg.classList.add('show');
      };
      const debounce = (fn, d=120) => { let id; return (...args)=>{ clearTimeout(id); id=setTimeout(()=>fn(...args), d); }; };
      const updateSuggestions = debounce(async (text) => {
        const v = (text||'').trim();
        if (!v) { sugg.classList.remove('show'); sugg.innerHTML=''; lastQuery=''; return; }
        if (v === lastQuery) return;
        lastQuery = v;
        try { renderSuggestions(await fetchSuggestions(v)); } catch { renderSuggestions(getFallbackSuggestions(v)); }
      }, 120);

      const setActive = (idx) => {
        const items = Array.from(sugg.querySelectorAll('li'));
        if (!items.length) { activeIndex = -1; return; }
        items.forEach((li,i)=>{ const a=i===idx; li.classList.toggle('active',a); li.setAttribute('aria-selected', a?'true':'false'); });
        activeIndex = idx; if (idx>=0) items[idx].scrollIntoView({block:'nearest'});
      };
      function handleSuggestionKeyboard(e) {
        const items = Array.from(sugg.querySelectorAll('li'));
        const isOpen = sugg.classList.contains('show') && items.length>0;
        switch (e.key) {
          case 'ArrowDown':
            if (!isOpen) { if (q.value.trim()) updateSuggestions(q.value); }
            else setActive((activeIndex+1)%items.length);
            e.preventDefault(); break;
          case 'ArrowUp':
            if (isOpen) { setActive(activeIndex<=0?items.length-1:activeIndex-1); e.preventDefault(); }
            break;
          case 'Enter':
            if (isOpen && activeIndex>=0) {
              const t = items[activeIndex].querySelector('span')?.textContent?.trim();
              if (t) q.value=t;
              sugg.classList.remove('show'); activeIndex=-1; e.preventDefault(); submitSearch();
            } break;
          case 'Escape':
            if (isOpen) { sugg.classList.remove('show'); activeIndex=-1; e.preventDefault(); }
            break;
        }
      }

      on(q, 'input', (e)=> updateSuggestions(e.target.value));
      on(q, 'focus', () => { const v=q.value.trim(); if (v) updateSuggestions(v); });
      on(q, 'keydown', handleSuggestionKeyboard);
      on(sugg, 'mousedown', (e)=> e.preventDefault());
      on(sugg, 'click', (e) => {
        const li = e.target.closest('li'); if (!li) return;
        const t = li.querySelector('span').textContent.trim();
        q.value = t; sugg.classList.remove('show'); submitSearch();
      });
      on(q, 'blur', () => setTimeout(()=>{ sugg.classList.remove('show'); activeIndex=-1; },120));

      // Voice
      on(voice, 'click', () => {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SR) { alert("Voice search isn't supported in this browser."); return; }
        voice.classList.add('recording'); voice.disabled=true;
        try {
          const rec = new SR(); rec.lang=navigator.language||'en-US'; rec.interimResults=true; rec.maxAlternatives=1;
          let transcript = q.value;
          rec.onresult = (ev) => {
            const res = ev.results[ev.results.length-1][0]?.transcript || '';
            if (res) transcript = res; q.value = transcript; q.focus(); q.setSelectionRange(q.value.length, q.value.length);
          };
          rec.onerror=()=>{}; rec.onend=()=>{ voice.classList.remove('recording'); voice.disabled=false; };
          rec.start();
        } catch { voice.classList.remove('recording'); voice.disabled=false; }
      });

      // Lens
  on(lensBtn, 'click', () => lensFile.click());
      on(lensFile, 'change', () => {
        if (lensFile.files && lensFile.files.length) {
          setTimeout(()=>{ lensForm.submit(); lensForm.reset(); },0);
        }
      });

      // Drag image over bar -> Lens
      const isImage = f => f && f.type && f.type.startsWith('image/');
      const enableDropUI = () => bar.classList.add('drop-active');
      const disableDropUI = () => bar.classList.remove('drop-active');
      on(bar, 'dragenter dragover', (e) => {
        if (e.dataTransfer && Array.from(e.dataTransfer.types).includes('Files')) {
          e.preventDefault(); e.stopPropagation(); enableDropUI(); e.dataTransfer.dropEffect='copy';
        }
      });
      on(bar, 'dragleave dragend', disableDropUI);
      on(bar, 'drop', (e) => {
        e.preventDefault(); e.stopPropagation(); disableDropUI();
        const files = e.dataTransfer?.files;
        if (!files || !files.length || !isImage(files[0])) return;
        try {
          const dt = new DataTransfer(); dt.items.add(files[0]); lensFile.files = dt.files;
          lensForm.submit(); lensForm.reset();
        } catch { lensFile.click(); }
      });

      // AI
      on(ai, 'click', () => {
        const v = q.value.trim(); const base = 'https://www.google.com/search?udm=50';
        window.location.href = v ? `${base}&q=${encodeURIComponent(v)}` : base;
      });

      // ---------------- Shortcuts module ----------------
      const sc = $('#shortcuts');
      const scGrid = $('#scGrid');
      const scAdd = $('#scAdd');
      const scAddFolder = $('#scAddFolder');
      const scEdit = $('#scEdit');
      const scEditIcon = $('#scEditIcon');
      const scExport = $('#scExport');
      const scImport = $('#scImport');
      const scImportFile = $('#scImportFile');

      const folderView = $('#folderView');
      const fvGrid = $('#fvGrid');
      const fvTitle = $('#fvTitle');
      const fvBack = $('#fvBack');
      const fvAdd = $('#fvAdd');
      const fvToggleEdit = $('#fvToggleEdit');
      const fvToggleIcon = $('#fvToggleIcon');

      const dialog = $('#scDialog');
      const overlay = $('#scOverlay');
      const scForm = $('#scForm');
      const scDialogTitle = $('#scDialogTitle');
      const inputTitle = $('#scTitle');
      const inputUrl = $('#scUrl');
      const rowUrl = $('#rowUrl');
      const rowLoc = $('#rowLocation');
      const selectLocation = $('#scLocation');
      const scLocationLabel = $('#scLocationLabel');
      const btnCancel = $('#scCancel');

    const store = {
        key: 'shortcuts.v1',
        load() {
      if (EXT.isConnected()) return null;
      try {
            const raw = localStorage.getItem(this.key);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            return Array.isArray(parsed.items) ? parsed.items : null;
          } catch { return null; }
        },
        save(items) {
      if (EXT.isConnected()) return; // Extension is source of truth
      try { localStorage.setItem(this.key, JSON.stringify({ items })); } catch {}
        },
        export(items) {
          const payload = { version: 1, exportedAt: new Date().toISOString(), items };
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const a = document.createElement('a');
          const pad = (n)=> String(n).padStart(2,'0');
          const d = new Date();
          const name = `shortcuts-${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}.json`;
          a.href = URL.createObjectURL(blob);
          a.download = name;
          document.body.appendChild(a);
          a.click();
          setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
        },
        async import(file) {
          const text = await file.text();
          const json = JSON.parse(text);
          return sanitizeImport(json);
        }
      };

      const uid = (p='id') => `${p}_${Math.random().toString(36).slice(2,9)}${Date.now().toString(36)}`;

      const defaultItems = () => ([
        { id: uid('fld'), type: 'folder', title: 'Work', children: [
          { id: uid('sc'), type: 'link', title: 'Gmail', url: 'https://mail.google.com' },
          { id: uid('sc'), type: 'link', title: 'Drive', url: 'https://drive.google.com' }
        ]},
        { id: uid('sc'), type: 'link', title: 'YouTube', url: 'https://youtube.com' },
        { id: uid('sc'), type: 'link', title: 'Maps', url: 'https://maps.google.com' },
        { id: uid('sc'), type: 'link', title: 'Translate', url: 'https://translate.google.com' }
      ]);

      const state = {
        items: store.load() || defaultItems(),
        edit: false,       // root grid edit mode
        folderEdit: false, // folder overlay edit mode
        folderOpen: null
      };

      // Extension-backed refresh: fetch bookmark bar and render
      async function refreshFromExtension() {
        try {
          const data = await EXT.getToolbar();
          if (data && Array.isArray(data.items)) {
            state.items = data.items;
            render();
          }
        } catch {}
      }
      // Expose for debounced broadcasts
      window.__extRefresh = refreshFromExtension;

      // Helpers
      const findById = (id, list=state.items, parent=null) => {
        for (let i=0;i<list.length;i++) {
          const item = list[i];
          if (item.id === id) return { item, parent, index: i, list };
          if (item.type === 'folder' && Array.isArray(item.children)) {
            const found = findById(id, item.children, item);
            if (found) return found;
          }
        }
        return null;
      };
      const listForContext = (ctx) => (!ctx || ctx === 'root') ? state.items : (findById(ctx)?.item?.children || []);
      const setListForContext = (ctx, newList) => {
        if (!ctx || ctx === 'root') state.items = newList;
        else { const f = findById(ctx); if (f?.item?.type === 'folder') f.item.children = newList; }
      };
      const removeById = (id) => {
        const found = findById(id);
        if (!found) return null;
        const [removed] = found.list.splice(found.index, 1);
        return removed || found.item;
      };
      const faviconFor = (url) => { try { const u = new URL(url); return `https://www.google.com/s2/favicons?sz=64&domain_url=${encodeURIComponent(u.origin)}`; } catch { return ''; } };

      // Icons
      const deleteIcon = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 6h18"/>
          <path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/>
          <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
          <path d="M10 11v6M14 11v6"/>
        </svg>
      `;
      const folderIcon = `
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 2h9a2 2 0 0 1 2 2z"/>
        </svg>
      `;

      // Render
      const tileHTML = (it, idx, editable=false) => {
        if (it.type === 'folder') {
          const count = (it.children || []).length;
          return `
            <li class="tile folder" role="listitem" data-id="${it.id}" data-type="folder" data-index="${idx}" draggable="${editable ? 'true':'false'}" title="${escapeHTML(it.title)}">
              <div class="favicon folder-ico" aria-hidden="true">${folderIcon}</div>
              <div class="label">${escapeHTML(it.title)}</div>
              <div class="count">${count}</div>
              <button class="action edit" title="Edit folder" aria-label="Edit folder">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M4 21h4l11-11a2.5 2.5 0 0 0-4-4L4 17v4z"></path>
                </svg>
              </button>
              <button class="action remove" title="Delete" aria-label="Delete">
                ${deleteIcon}
              </button>
            </li>
          `;
        } else {
          const icon = faviconFor(it.url);
          return `
            <li class="tile link" role="listitem" data-id="${it.id}" data-type="link" data-index="${idx}" draggable="${editable ? 'true':'false'}" title="${escapeHTML(it.title)} • ${escapeHTML(it.url)}">
              <div class="favicon" aria-hidden="true">
                ${icon ? `<img src="${icon}" alt="">` : `
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
                    <circle cx="12" cy="12" r="4"></circle>
                  </svg>
                `}
              </div>
              <div class="label">${escapeHTML(it.title)}</div>
              <button class="action edit" title="Edit shortcut" aria-label="Edit shortcut">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M4 21h4l11-11a2.5 2.5 0 0 0-4-4L4 17v4z"></path>
                </svg>
              </button>
              <button class="action remove" title="Delete" aria-label="Delete">
                ${deleteIcon}
              </button>
            </li>
          `;
        }
      };

      const renderGrid = (gridEl, ctx='root') => {
        const list = listForContext(ctx);
        const editable = ctx === 'root' ? state.edit : state.folderEdit;
        gridEl.dataset.context = ctx;
        gridEl.innerHTML = list.map((it, i) => tileHTML(it, i, editable)).join('');
      };

      const render = () => {
        renderGrid(scGrid, 'root');
        sc.classList.toggle('edit', state.edit);
        scEdit.setAttribute('aria-pressed', String(state.edit));
        scEditIcon.innerHTML = state.edit
          ? '<path d="M5 12h14M5 6h14M5 18h14"></path>'
          : '<path d="M4 21h4l11-11a2.5 2.5 0 0 0-4-4L4 17v4z"></path>';

        if (state.folderOpen) {
          const f = findById(state.folderOpen)?.item;
          if (!f) { closeFolder(); }
          else {
            fvTitle.textContent = f.title;
            renderGrid(fvGrid, state.folderOpen);
            folderView.classList.toggle('edit', state.folderEdit);
            fvToggleEdit.setAttribute('aria-pressed', String(state.folderEdit));
            fvToggleIcon.innerHTML = state.folderEdit
              ? '<path d="M5 12h14M5 6h14M5 18h14"></path>'
              : '<path d="M4 21h4l11-11a2.5 2.5 0 0 0-4-4L4 17v4z"></path>';
          }
        }
        store.save(state.items);
      };

      // Folder open/close
  const openFolder = (folderId) => {
        const f = findById(folderId)?.item;
        if (!f || f.type !== 'folder') return;
        state.folderOpen = folderId;
        state.folderEdit = false;
        fvTitle.textContent = f.title;
        renderGrid(fvGrid, folderId);
        folderView.classList.add('show');
        folderView.setAttribute('aria-hidden', 'false');
        render();
      };
      const closeFolder = () => {
        state.folderOpen = null;
        state.folderEdit = false;
        folderView.classList.remove('show', 'edit');
        folderView.setAttribute('aria-hidden', 'true');
        render();
      };

      // Dialog state
      let dialogState = { mode: 'link', editId: null };

      const buildLocationOptions = () => {
        const options = [['root', 'Top level']];
        for (const it of state.items) { if (it.type === 'folder') options.push([it.id, `Folder: ${it.title}`]); }
        selectLocation.innerHTML = options.map(([v,t]) => `<option value="${v}">${escapeHTML(t)}</option>`).join('');
      };

      const openDialog = (mode='link', preset = {}, editId = null) => {
        dialogState = { mode, editId };
        scDialogTitle.textContent =
          editId ? (mode === 'folder' ? 'Rename folder' : 'Edit shortcut')
                 : (mode === 'folder' ? 'New folder'   : 'Add shortcut');

        // Fields
        rowUrl.style.display = mode === 'link' ? 'flex' : 'none';

        const showLocation = (mode === 'link'); // Add+Edit links show location ("Add to" / "Move to")
        rowLoc.style.display = showLocation ? 'flex' : 'none';
        if (showLocation) {
          buildLocationOptions();
          scLocationLabel.textContent = editId ? 'Move to' : 'Add to';
          let currentLoc = 'root';
          if (editId) {
            const found = findById(editId);
            if (found) currentLoc = found.parent?.id || 'root';
          } else {
            currentLoc = preset.location ?? (state.folderOpen || 'root');
          }
          selectLocation.value = currentLoc;
        }

        inputTitle.value = preset.title || '';
        inputUrl.value = preset.url || '';
        overlay.classList.add('show');
        dialog.classList.add('show');
        inputTitle.focus();
      };
      const closeDialog = () => { dialog.classList.remove('show'); overlay.classList.remove('show'); };

      const openEdit = (id) => {
        const found = findById(id);
        if (!found) return;
        const it = found.item;
        if (it.type === 'folder') openDialog('folder', { title: it.title }, it.id);
        else openDialog('link', { title: it.title, url: it.url }, it.id);
      };

      // Click handlers (root grid)
      on(scGrid, 'click', async (e) => {
        const tile = e.target.closest('.tile'); if (!tile) return;
        const rm = e.target.closest('.remove');
        const ed = e.target.closest('.edit');

        if (rm && state.edit) {
          const id = tile.dataset.id;
          if (EXT.isConnected()) { try { await EXT.removeNode({ id }); await refreshFromExtension(); } catch {} }
          else { removeById(id); render(); }
          return;
        }
        if (ed && state.edit) { openEdit(tile.dataset.id); return; }
        if (state.edit) return;

        const type = tile.dataset.type;
        const id = tile.dataset.id;
        const found = findById(id)?.item; if (!found) return;

        if (type === 'folder') openFolder(id);
        else if (type === 'link') window.open(found.url, (e.metaKey||e.ctrlKey)?'_blank':'_self', 'noopener');
      });

      // Click handlers (folder grid)
      on(fvGrid, 'click', async (e) => {
        const tile = e.target.closest('.tile'); if (!tile) return;
        const rm = e.target.closest('.remove');
        const ed = e.target.closest('.edit');

        if (rm && state.folderEdit) {
          const id = tile.dataset.id;
          if (EXT.isConnected()) { try { await EXT.removeNode({ id }); await refreshFromExtension(); } catch {} }
          else { removeById(id); render(); }
          return;
        }
        if (ed && state.folderEdit) { openEdit(tile.dataset.id); return; }
        if (state.folderEdit) return;

        const type = tile.dataset.type;
        const id = tile.dataset.id;
        const found = findById(id)?.item; if (!found) return;

        if (type === 'folder') openFolder(id); // not expected (one-level model), but safe
        else if (type === 'link') window.open(found.url, (e.metaKey||e.ctrlKey)?'_blank':'_self', 'noopener');
      });

      // DnD (reorder + move into folder)
      let dragInfo = null;
      const isGridEditable = (grid) => (grid === scGrid ? state.edit : state.folderEdit);

      const clearDropHighlights = () => { $$('.tile.drop-into, .tile.drop-before, .tile.drop-after').forEach(el => el.classList.remove('drop-into','drop-before','drop-after')); };

      const reorderWithin = (ctx, draggedId, beforeId=null) => {
        const list = listForContext(ctx).slice();
        const fromIdx = list.findIndex(x => x.id === draggedId);
        if (fromIdx < 0) return false;
        const [item] = list.splice(fromIdx, 1);
        let toIdx = beforeId ? list.findIndex(x => x.id === beforeId) : list.length;
        if (toIdx < 0) toIdx = list.length;
        list.splice(toIdx, 0, item);
        setListForContext(ctx, list);
        return true;
      };

      const attachDnD = (grid) => {
        on(grid, 'dragstart', (e) => {
          const tile = e.target.closest('.tile'); if (!tile) return;
          const currentGrid = tile.closest('ul');
          if (!isGridEditable(currentGrid)) return;
          dragInfo = { id: tile.dataset.id, fromCtx: currentGrid?.dataset?.context || 'root' };
          tile.classList.add('dragging');
          try { e.dataTransfer.setData('text/plain', dragInfo.id); } catch {}
        });
        on(grid, 'dragend', (e) => {
          const tile = e.target.closest('.tile'); if (tile) tile.classList.remove('dragging');
          dragInfo = null; clearDropHighlights();
        });
        on(grid, 'dragover', (e) => {
          const currentGrid = e.currentTarget;
          if (!isGridEditable(currentGrid) || !dragInfo) return;
          e.preventDefault();
          const overTile = e.target.closest('.tile');
          clearDropHighlights();
          if (overTile) {
            const type = overTile.dataset.type;
            if (type === 'folder' && findById(dragInfo.id)?.item.type === 'link') overTile.classList.add('drop-into');
          }
        });
        on(grid, 'drop', async (e) => {
          const currentGrid = e.currentTarget;
          if (!isGridEditable(currentGrid) || !dragInfo) return;
          e.preventDefault();

          const toCtx = currentGrid.dataset.context || 'root';
          const overTile = e.target.closest('.tile');
          const dragged = findById(dragInfo.id)?.item;
          if (!dragged) return;

          if (overTile) {
            const overId = overTile.dataset.id;
            const overType = overTile.dataset.type;

            // Only links into folders (no sub-folders)
            if (overType === 'folder' && dragged.type === 'link') {
              if (EXT.isConnected()) {
                const parentId = overId; // move into folder
                try { await EXT.moveNode({ id: dragged.id, parentId }); await refreshFromExtension(); } catch {}
              } else {
                removeById(dragInfo.id);
                const folder = findById(overId)?.item;
                folder.children = folder.children || [];
                folder.children.push(dragged);
                render();
              }
              return;
            }

            if (dragInfo.fromCtx !== toCtx) {
              if (EXT.isConnected()) {
                const parentId = (toCtx === 'root') ? EXT.getToolbarRootId() : toCtx;
                // Insert before overId => compute index of overId in target list
                const list = listForContext(toCtx);
                const toIdx = Math.max(0, list.findIndex(x => x.id === overId));
                try { await EXT.moveNode({ id: dragged.id, parentId, index: toIdx }); await refreshFromExtension(); } catch {}
              } else {
                const extracted = removeById(dragInfo.id); if (!extracted) return;
                const list = listForContext(toCtx).slice();
                const toIdx = list.findIndex(x => x.id === overId);
                list.splice(toIdx < 0 ? list.length : toIdx, 0, extracted);
                setListForContext(toCtx, list); render();
              }
              return;
            } else {
              if (EXT.isConnected()) {
                const parentId = (toCtx === 'root') ? EXT.getToolbarRootId() : toCtx;
                const list = listForContext(toCtx);
                const toIdx = Math.max(0, list.findIndex(x => x.id === overId));
                try { await EXT.moveNode({ id: dragged.id, parentId, index: toIdx }); await refreshFromExtension(); } catch {}
              } else {
                reorderWithin(toCtx, dragInfo.id, overId); render();
              }
              return;
            }
          } else {
            // Drop into empty grid area => move to end
            if (dragInfo.fromCtx !== toCtx) {
              if (EXT.isConnected()) {
                const parentId = (toCtx === 'root') ? EXT.getToolbarRootId() : toCtx;
                try { await EXT.moveNode({ id: dragged.id, parentId }); await refreshFromExtension(); } catch {}
              } else {
                const extracted = removeById(dragInfo.id); if (!extracted) return;
                const list = listForContext(toCtx).slice(); list.push(extracted);
                setListForContext(toCtx, list); render();
              }
            } else {
              if (EXT.isConnected()) {
                const parentId = (toCtx === 'root') ? EXT.getToolbarRootId() : toCtx;
                try { await EXT.moveNode({ id: dragged.id, parentId }); await refreshFromExtension(); } catch {}
              } else {
                reorderWithin(toCtx, dragInfo.id, null); render();
              }
            }
          }
        });
      };
      attachDnD(scGrid);
      attachDnD(fvGrid);

      // Top bar buttons
  on(scAdd, 'click', () => openDialog('link'));
  on(scAddFolder, 'click', () => openDialog('folder')); // always top-level
      on(scEdit, 'click', () => { state.edit = !state.edit; render(); });

      // Folder controls
      on(fvBack, 'click', closeFolder);
      on(fvAdd, 'click', () => openDialog('link', { location: state.folderOpen }));
      on(fvToggleEdit, 'click', () => { state.folderEdit = !state.folderEdit; render(); });

      // Dialog interactions
      on(overlay, 'click', closeDialog);
      on(btnCancel, 'click', closeDialog);
      on(scForm, 'submit', async (e) => {
        e.preventDefault();
        const title = inputTitle.value.trim();
        const mode = dialogState.mode;

        // Edit existing
        if (dialogState.editId) {
          const found = findById(dialogState.editId);
          if (!found) { closeDialog(); return; }

          if (mode === 'folder') {
            if (EXT.isConnected()) {
              try { await EXT.updateNode({ id: found.item.id, title: title || 'Folder' }); await refreshFromExtension(); } catch {}
            } else {
              found.item.title = title || 'Folder'; render();
            }
            closeDialog(); return;
          }

          // Edit link + Move to...
          let url = inputUrl.value.trim();
          try {
            if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
            new URL(url);
          } catch { alert('Please enter a valid URL.'); return; }
          const name = title || (new URL(url).hostname.replace(/^www\./,''));
          const currentLoc = found.parent?.id || 'root';
          const newLoc = (rowLoc.style.display !== 'none') ? (selectLocation.value || currentLoc) : currentLoc;

          if (EXT.isConnected()) {
            try {
              await EXT.updateNode({ id: found.item.id, title: name, url });
              if (newLoc !== currentLoc) {
                const parentId = (newLoc === 'root') ? EXT.getToolbarRootId() : newLoc;
                await EXT.moveNode({ id: found.item.id, parentId });
              }
              await refreshFromExtension();
            } catch {}
          } else {
            if (newLoc === currentLoc) {
              found.item.title = name; found.item.url = url;
            } else {
              const updated = removeById(dialogState.editId);
              if (updated) {
                updated.title = name; updated.url = url;
                if (newLoc === 'root') state.items.push(updated);
                else {
                  const folder = findById(newLoc)?.item;
                  folder.children = folder.children || [];
                  folder.children.push(updated);
                }
              }
            }
            render();
          }
          closeDialog(); return;
        }

        // Create new
        if (mode === 'link') {
          let url = inputUrl.value.trim();
          if (!url) return;
          try {
            if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
            new URL(url);
          } catch { alert('Please enter a valid URL.'); return; }
          const name = title || (new URL(url).hostname.replace(/^www\./,''));
          const loc = (selectLocation.value || 'root');
          if (EXT.isConnected()) {
            const parentId = (loc === 'root') ? EXT.getToolbarRootId() : loc;
            try { await EXT.createLink({ parentId, title: name, url }); await refreshFromExtension(); } catch {}
          } else {
            const item = { id: uid('sc'), type: 'link', title: name, url };
            if (loc === 'root') state.items.push(item);
            else {
              const folder = findById(loc)?.item;
              if (folder?.type === 'folder') { folder.children = folder.children || []; folder.children.push(item); }
              else state.items.push(item);
            }
          }
        } else {
          // New folder: always top-level
          const name = title || 'New folder';
          if (EXT.isConnected()) {
            try { await EXT.createFolder({ parentId: EXT.getToolbarRootId(), title: name }); await refreshFromExtension(); } catch {}
          } else {
            state.items.push({ id: uid('fld'), type: 'folder', title: name, children: [] });
          }
        }

        if (!EXT.isConnected()) render();
        closeDialog();
        inputTitle.value = ''; inputUrl.value = '';
      });

      // Import/Export
      const sanitizeImport = (input) => {
        const out = [];
        const seen = new Set();
        const newId = (isFolder) => {
          let id; do { id = uid(isFolder ? 'fld' : 'sc'); } while (seen.has(id));
          seen.add(id); return id;
        };
        const validUrl = (u) => {
          try { if (!/^https?:\/\//i.test(u)) u = 'https://' + u; const url = new URL(u); return url.href; }
          catch { return null; }
        };
        const addLink = (title, url) => {
          const href = validUrl(url); if (!href) return null;
          return { id: newId(false), type: 'link', title: String(title||new URL(href).hostname.replace(/^www\./,'')), url: href };
        };
        const each = Array.isArray(input) ? input : (Array.isArray(input?.items) ? input.items : []);
        for (const it of each) {
          if (!it || typeof it !== 'object') continue;
          if (it.type === 'folder') {
            const folder = { id: newId(true), type: 'folder', title: String(it.title || 'Folder'), children: [] };
            const kids = Array.isArray(it.children) ? it.children : [];
            for (const ch of kids) {
              if (ch?.type === 'link') {
                const link = addLink(ch.title, ch.url);
                if (link) folder.children.push(link);
              } else if (ch?.type === 'folder' && Array.isArray(ch.children)) {
                // Flatten nested folders: keep their links
                for (const sub of ch.children) {
                  if (sub?.type === 'link') {
                    const link = addLink(sub.title, sub.url);
                    if (link) folder.children.push(link);
                  }
                }
              }
            }
            out.push(folder);
          } else if (it.type === 'link') {
            const link = addLink(it.title, it.url);
            if (link) out.push(link);
          }
        }
        return out;
      };

      on(scExport, 'click', () => store.export(state.items));
      on(scImport, 'click', () => {
        if (EXT.isConnected()) { alert('Import is disabled while syncing with bookmarks.'); return; }
        scImportFile.click();
      });
      on(scImportFile, 'change', async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          const imported = await store.import(file);
          if (!imported.length) { alert('No shortcuts found in file.'); return; }
          if (confirm('Replace current shortcuts with imported data?\nPress OK to Replace, Cancel to Merge.')) {
            state.items = imported;
          } else {
            state.items = state.items.concat(imported);
          }
          render();
        } catch (err) {
          console.warn('Import failed:', err);
          alert('Could not import file. Please ensure it is a valid shortcuts JSON.');
        } finally {
          scImportFile.value = '';
        }
      });

      // Keyboard: ESC closes folder or dialog
      on(document, 'keydown', (e) => {
        if (e.key === 'Escape') {
          if (dialog.classList.contains('show')) { closeDialog(); return; }
          if (folderView.classList.contains('show')) { closeFolder(); return; }
        }
      });

      // Init: attempt to connect to extension; if connected, load bookmarks, else fallback to local
      (async () => {
        // Localize Google params
        try { const hl = (navigator.language || 'en').split('-')[0] || 'en'; document.getElementById('lensHl').value = hl; } catch {}

        const data = await EXT.connect();
        if (data && Array.isArray(data.items)) {
          state.items = data.items;
          // Disable import UI when syncing
          scImport.setAttribute('disabled', 'true');
          render();
          // Tiny connection indicator (non-intrusive)
          try { const el = document.createElement('div'); el.style.cssText='position:fixed;right:8px;bottom:8px;font:12px system-ui;color:#8bbdff;opacity:.6;user-select:none;'; el.textContent='Synced with Bookmarks'; document.body.appendChild(el); setTimeout(()=>el.remove(), 3000); } catch {}
        } else {
          render();
        }
      })();
    })();
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(() => {});
      });
    }
  </script>
</body>
</html>
